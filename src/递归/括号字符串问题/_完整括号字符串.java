package 递归.括号字符串问题;

/**
 * @author zhp
 * @date 2022-07-03 11:54
 *
 *完整括号字符串问题集合
 *
 */
public class _完整括号字符串 {
    /**补充括号实现完整括号字符串（lc_678：
     *   给定一个只包含两种字符的字符串：（ ，）写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
     *
     *   任何左括号 ( 必须有相应的右括号 )。
     *   任何右括号 ) 必须有相应的左括号 ( 。
     *   左括号 ( 必须在对应的右括号之前 )。
     *    可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
     *   一个空字符串也被视为有效字符串。
     *   如果有不完整的字符串，需要计算并返回需要添加的括号数量
     *
     * 题解思路：
     * 使用少数几个变量就可以实现，
     * 用count记录遍历字符串时，出现（与）括号的数值之和，遇到（就+1，反之-1
     * 再使用ans记录count为负数时，也就是出现一个没有匹配的）时的数量，并将为负数的count置为0
     * 最后的count一定为0或者为整数，表示的就是该字符串中没有匹配的（的数量，而ans记录的是没有匹配的）数量
     */
    public static int process(String str) {
        if(str==null || str.length()==0){
            return 0;
        }

        int ans = 0;
        int count = 0;

        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='('){
                count++;
            }else{//为')'时
                if(count==0){//此时遇到‘）’应该继续count--，再将count置0，这里直接合并两个操作
                    ans++;
                }else{
                    count--;
                }
            }
        }
        return count+ans;
    }

    /**括号深度问题：
     * 一个合法的括号匹配序列有以下定义:
     * ①空串""是一个合法的括号匹配序列
     * ②如果"X"和"Y"都是合法的括号匹配序列,"XY"也是一个合法的括号匹配序列
     * ③如果"X"是一个合法的括号匹配序列,那么"(X)"也是一个合法的括号匹配序列
     * ④每个合法的括号序列都可以由以上规则生成。
     * 例如: "","()","()()","((()))"都是合法的括号序列
     * 对于一个合法的括号序列我们又有以下定义它的深度:
     * ①空串""的深度是0
     * ②如果字符串"X"的深度是x,字符串"Y"的深度是y,那么字符串"XY"的深度为
     * max(x,y) 3、如果"X"的深度是x,那么字符串"(X)"的深度是x+1
     * 例如: "()()()"的深度是1,"((()))"的深度是3。牛牛现在给你一个合法的括号
     * 序列,需要你计算出其深度
     *
     * 题解思路：
     * 题目变型，但基本原理还是不变，同上述题目步骤基本一致，只需要求出最长连续左括号长度即可
     * 就是count从左往右，遇到（就++，遇到）就--,最后count就是深度
     */
    public static int process1(String str){
        if(str==null || str.length()==0){
            return -1;
        }
        int count =0 ;

        char[] chars = str.toCharArray();
        for (int i = 0; i <chars.length ; i++) {
            if(chars[i]=='('){
                count++;
            }else{
                count--;
            }
        }
        return count;
    }

    /**最长有效括号问题（lc_32)：
     * 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode.cn/problems/longest-valid-parentheses
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * 题目思路：
     * 使用dp来解答，dp[i]表示以下标为i的字符结尾时，字符串中以及出现的最长有效括号
     * 1.每当遇到（时，直接置数值为0，因为出现左括号时不可能出现有效括号
     * 2.出现）时，开始进行判断：
     *      首先判断当前字符的前一个字符来先前推（因为当前字符的前一个字符一定是最长括号）
     *      推到了指定位置之后，需要判断当前字符是否为左括号，是的话说明可以和当前遍历到的
     *      右括号构成一个新的最长括号。
     *      但是，到这里还没结束，我们仍需要判断这个推导到的字符的前一个字符是否存在有效括号，
     *      存在的话，需要加上该值。将先前的已经存在的有效括号字符串与我们新发现的有效字符串融合起来
     *
     *  具体情况可见推导图
     */
    public static int process3(String str){
        if(str==null || str.length()==0){
            return 0;
        }

        char[] chars = str.toCharArray();
        int [] dp = new int[chars.length] ;
        int pre = 0;//记录前一个字符的位置
        int res = 0;//记录答案
        for(int i=1;i<chars.length;i++){
            if(chars[i]==')'){
                pre = i-dp[i-1]-1;//找到应该向前推导到并进行比较的字符坐标
                if(pre>=0 && chars[pre]=='('){//pre存在并且可以和当前遍历到的‘）’构成新的最长有效字符串
                    dp[i] = dp[i-1]+2 ;//加2是包含推导字符与当前遍历到的字符
                    dp[i] += (pre>0? dp[pre-1]:0);//加上推导字符前的最长有效字符串
                }
            }
            res = Math.max(res,dp[i]);//记录最大值
        }
        return  res;
    }

    public static void main(String[] args) {
        System.out.println(process3("(()()))))"));
    }

}
